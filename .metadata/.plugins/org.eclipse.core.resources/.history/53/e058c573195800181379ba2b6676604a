package Controller;

import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

import javax.swing.ImageIcon;
import javax.swing.JButton;

import Conexion.Conexion;
import Model.Calle;
import Model.Casilla;
import Model.Combate;
import Model.Dado;
import Model.Personaje;
import Model.Protagonista;
import Model.Recompensa;
import Model.TableroModel;
import View.BatallaView;
import View.BatoiKillerView;
import View.DadoVista;
import View.GameOverView;
import View.GameWinView;
import View.RecompensaView;
import resources.CompoundIcon;

@SuppressWarnings("unused")
public class BatoiKillerController implements KeyListener, ActionListener, Runnable {
	
	private Thread hilo; //Hilo del cronometro
	private TableroModel modelo; //Clase principal del modelo
	private TitleController title; //Controlador de la pantalla de Titulo
	private ElecController elec; //Controlador de la pantalla de Configuracion de la partida
	private BatoiKillerView ventana; //Ventana principal del juego
	private DadoVista dado; //Ventana para visualizar el Dado
	private BatallaView batalla; //Ventana automatica de combate
	private RecompensaView recompensa; //Ventana de recompensa
	private GameOverView gameOver; //Ventana de GameOver
	private GameWinView gameWin; //Ventana de GameWin (Has ganado el juego)
	private Integer minutos = 0, segundos = 0; //Datos del Cronometro
	private int movimientos; //Movimientos del protagonista
	private boolean semaforo = false; //Semaforo que controla si el dado ha sido lanzado y al Prota le quedan movimientos
	/*
	 * Constructor del Controlador principal del programa, por orden crea:
	 * El controlador de la pantalla de titulo
	 * El controlador de la pantalla de creacion de personaje, dificultad y nombre
	 * El modelo de la ventana principal, al cual le pasamos la dificultad seleccionada anteriormente
	 * Hacemos cambios al Sprite (imagen) del protagonista y su nombre si hiciera falta
	 * Se crea la vista principal del juego
	 * Y por ultimo la vista del dado, que se crea invisible y solo se muestra cuando sea necesario
	 */
	public BatoiKillerController() {
		this.title = new TitleController();
		if (!this.title.isCargarPartida()) {
			this.elec = new ElecController();
			this.modelo = new TableroModel(elec.getVentana().getDificultad());
			this.modelo.getCasillas()[5][5].getPersonajes()[1].setRuta(elec.getVentana().getRuta());
			if (elec.getVentana().getNombreTxt().getText().length() > 1) {
				Protagonista.setNombre(elec.getVentana().getNombreTxt().getText());
			}
		} else {
			Casilla[][] casillas = Conexion.getInstance().cargar();
			this.modelo = new TableroModel(casillas);
		}
		this.ventana = new BatoiKillerView(modelo);
		this.dado = new DadoVista();
		setActions();
		iniciarCronometro();
	}
	
	private void iniciarCronometro() {
        hilo = new Thread( this );
        hilo.start();
    }
	@Override
	public void run() {
		System.out.println("Empieza Contador");
		Integer milesimas = 0;
        try {
            while(this.ventana.isVisible()) {
                Thread.sleep( 4 );
                milesimas += 4;
                if( milesimas == 1000 ) {
                    milesimas = 0;
                    segundos += 1;
                    if( segundos == 60 ) {
                        segundos = 0;
                        minutos++;
                    }
                    System.out.println(minutos + " " + segundos);
                } 
            }
        }catch(Exception e){
        	e.printStackTrace();
        }
		
	}
	/*
	 * Colocamos los escuchadores necesarios a los elementos de la vista que los necesiten
	 */
	private void setActions() {
		this.ventana.getAbajo().addActionListener(this);
		this.ventana.getArriba().addActionListener(this);
		this.ventana.getDerecha().addActionListener(this);
		this.ventana.getIzquierda().addActionListener(this);
		this.ventana.getStop().addActionListener(this);
		this.ventana.getDado().addActionListener(this);
		this.ventana.getSave().addActionListener(this);
		
		this.ventana.getBoton().addKeyListener(this);
		this.ventana.getBoton().setFocusable(true);
		this.ventana.getBoton().setFocusTraversalKeysEnabled(false);
	}

	/*
	 * Metodo @Override del ActionListener
	 * Desde aqui dirigimos el comportamiento del juego a su respectivo metodo privado
	 */
	
	@Override
	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == this.ventana.getArriba()) {
			moveHeroe(0x26);
		} else if(e.getSource() == this.ventana.getAbajo()) {
			moveHeroe(0x28);
		} else if(e.getSource() == this.ventana.getIzquierda()) {
			moveHeroe(0x25);
		} else if(e.getSource() == this.ventana.getDerecha()) {
			moveHeroe(0x27);
		} else if(e.getSource() == this.ventana.getStop()) {
			this.movimientos = 0;
		} else if(e.getSource() == this.ventana.getDado()) {
			if (movimientos == 0) {
				semaforo = true;
				this.movimientos = Dado.getNewNumero();
				this.dado.getImg().setIcon(new ImageIcon(getClass().getResource("../resources/extras/" + movimientos + ".png")));
				this.movimientos += Integer.parseInt("" + this.ventana.getVelocidadP().getText().charAt(0));
				this.dado.setVisible(true);
			}
		} else if(e.getSource() == this.ventana.getSave()) {
			System.out.println("Guardando...");
			Conexion.getInstance().guardar(this.modelo.getCasillas());
		}
		if(this.movimientos == 0 && semaforo) { //Si ha acabado el turno y el dado ha sido lanzado
			comprobarEvento(); //Comprobar al mover al personaje por ultima vez
			moveEnemy(); //Mover los enemigos
			comprobarEvento(); //Volver a comprobar que no se deba lanzar algun evento
			comprobarGameWin();
			semaforo = false;
		}
		this.ventana.getDadoNum().setText("" + movimientos);//Actualizar la visualizacion de los movimientos
	}
	
	@Override
	public void keyPressed(KeyEvent k) {
		if(k.getKeyCode() == KeyEvent.VK_UP) {
			moveHeroe(0x26);
		} else if(k.getKeyCode() == KeyEvent.VK_DOWN) {
			moveHeroe(0x28);
		} else if(k.getKeyCode() == KeyEvent.VK_LEFT) {
			moveHeroe(0x25);
		} else if(k.getKeyCode() == KeyEvent.VK_RIGHT) {
			moveHeroe(0x27);
		} else if(k.getKeyCode() == KeyEvent.VK_ENTER) {
			if (movimientos == 0) {
				semaforo = true;
				this.movimientos = Dado.getNewNumero();
				this.dado.getImg().setIcon(new ImageIcon(getClass().getResource("../resources/extras/" + movimientos + ".png")));
				this.movimientos += Integer.parseInt("" + this.ventana.getVelocidadP().getText().charAt(0));
				this.dado.setVisible(true);
			} else {
				this.movimientos = 0;
			}
		}
		if(this.movimientos == 0 && semaforo) { //Si ha acabado el turno y el dado ha sido lanzado
			comprobarEvento(); //Comprobar al mover al personaje por ultima vez
			moveEnemy(); //Mover los enemigos
			comprobarEvento(); //Volver a comprobar que no se deba lanzar algun evento
			comprobarGameWin();
			semaforo = false;
		}
		this.ventana.getDadoNum().setText("" + movimientos);//Actualizar la visualizacion de los movimientos
	}

	@Override
	public void keyReleased(KeyEvent k) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void keyTyped(KeyEvent k) {
		// TODO Auto-generated method stub
		
	}
	
	private void comprobarGameWin() {
		String ruta = "";
		String pt = "";
		String tiempo = "";
		String dificultad = "";
		for (int i = 0; i < this.modelo.getCasillas().length; i++) {
			for (int j = 0; j < this.modelo.getCasillas()[i].length; j++) {
				if(this.modelo.getCasillas()[i][j].getPersonajes()[0] != null) { //Encontrado un enemigo
					return;
				} else if(this.modelo.getCasillas()[i][j].getPersonajes()[1] != null) { //Encontrado el Protagonista
					ruta = this.modelo.getCasillas()[i][j].getPersonajes()[1].getRuta();
				}
			}
		}
		pt = this.ventana.getTotalP().getText();
		tiempo = this.minutos + ":" + this.segundos;
		if(TableroModel.getDificultad() == 1) {
			dificultad = "Fácil";
		} else if(TableroModel.getDificultad() == 3) {
			dificultad = "Normal";
		} else {
			dificultad = "Difícil";
		}
		FicheroController.getInstance().escribir(pt);
		
		this.ventana.setVisible(false);
		this.ventana.dispose();
		this.gameWin = new GameWinView(ruta, pt, tiempo, dificultad);
	}
	/*
	 * Metodo que comprueba y ejecuta un evento si fuera necesario
	 * Busca la posicion del Protagonista, para luego comprobar en que casilla se encuentra
	 * Si es Combate se ejecuta la vista automatica de combate (sin controlador ya que es automatica)
	 * Y tras el combate se hacen los cambios necesarios en el tablero o se ejecuta la vista de GameOver
	 * 
	 * En caso de Recompensa, se ejecuta la vista de recompensa tambien automatica
	 * 
	 * Finalmente se actualizan las estadisticas del jugador
	 */
	
	private void comprobarEvento() {
		for (int i = 0; i < this.modelo.getCasillas().length; i++) {
			for (int j = 0; j < this.modelo.getCasillas()[i].length; j++) {
				if(this.modelo.getCasillas()[i][j].getPersonajes()[1] != null) { //Encontrado el Protagonista
					if(this.modelo.getCasillas()[i][j].getEvento() instanceof Combate) { //Entrar en caso de Combate
				        this.batalla = new BatallaView(this.modelo.getCasillas()[i][j]);
						if(this.modelo.getCasillas()[i][j].getPersonajes()[1].getEnergia() <= 0) {//En caso de perder el combate (acabar del juego)
							this.ventana.dispose();
							this.gameOver = new GameOverView(this.modelo.getCasillas()[i][j].getPersonajes()[1].getRuta());
							System.exit(0);
						} else if(this.modelo.getCasillas()[i][j].getPersonajes()[0].getEnergia() <= 0) { // En caso de ganar el combate
							//Actualizar oro ganado
							this.modelo.getCasillas()[i][j].getPersonajes()[1].setOro(this.modelo.getCasillas()[i][j].getPersonajes()[1].getOro()+this.modelo.getCasillas()[i][j].getPersonajes()[0].getOro());
							//borrar enemigo
							this.modelo.getCasillas()[i][j].getPersonajes()[0] = null;
						}
						//Una vez acabado el combate y devolver el evento Recompensa a la casilla
						this.modelo.getCasillas()[i][j].setEvento(Recompensa.getInstance());
					} else {//Entrar en caso de Recompensa
						if(!(this.modelo.getCasillas()[i][j].getEdificio() instanceof Calle)) {
							if (recompensa == null || !recompensa.isVisible()) {
								//Lanzar vista de Recompensa con el modelo de la casilla actual
								recompensa = new RecompensaView(this.modelo.getCasillas()[i][j]);
								this.modelo.getCasillas()[i][j].setEdificio(new Calle());
							} 
						}
					}
					//pintar protagonista en la casilla
					Image fondo = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[i][j].getEdificio().getRuta())).getImage();
					Image personaje = new ImageIcon(getClass().getResource(ventana.getModelo().getCasillas()[i][j].getPersonajes()[1].getRuta())).getImage();
					this.ventana.getTablero()[i][j].setIcon(new CompoundIcon(
							new ImageIcon(fondo.getScaledInstance(60, 60, Image.SCALE_SMOOTH)),
							new ImageIcon(personaje.getScaledInstance(60, 60, Image.SCALE_SMOOTH))
							));
					this.ventana.actualizarStats(this.modelo.getCasillas()[i][j].getPersonajes()[1]);
				}
			}
		}
	}	
	/*
	 * Metodo que controla el movimiento de los enemigos una vez el protagonista ha acabado el turno
	 */
	private void moveEnemy() {
		ArrayList <Personaje> enemigos = new ArrayList<Personaje>();
		int movimientos = 0;
		int elec = Dado.getNew4();
		int fila = 0;
		int columna = 0;
		Personaje enemy = null;
		for (int i = 0; i < this.modelo.getCasillas().length; i++) {
			for (int j = 0; j < this.modelo.getCasillas()[i].length; j++) {
				if(this.modelo.getCasillas()[i][j].getPersonajes()[0] != null && !enemigos.contains(this.modelo.getCasillas()[i][j].getPersonajes()[0])) {
					enemy = this.modelo.getCasillas()[i][j].getPersonajes()[0];
					fila = i;
					columna = j;
					Image personaje;
					Image fondo = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[fila][columna].getEdificio().getRuta())).getImage();
					if(this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1] != null) {
						personaje = new ImageIcon(getClass().getResource(this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1].getRuta())).getImage();
						this.ventana.getTablero()[fila][columna].setIcon(new CompoundIcon(
								new ImageIcon(fondo.getScaledInstance(60, 60, Image.SCALE_SMOOTH)),
								new ImageIcon(personaje.getScaledInstance(60, 60, Image.SCALE_SMOOTH))
								));
					} else {
						this.ventana.getTablero()[fila][columna].setIcon(new ImageIcon(fondo.getScaledInstance(60, 60, Image.SCALE_SMOOTH)));
					}
					this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[0] = null;
					this.modelo.getCasillas()[fila][columna].setEvento(Recompensa.getInstance());
					int emergency_exit = 0;
					while(movimientos != 6 || emergency_exit > 100) {
						elec = Dado.getNew4();
						switch (elec) {
						case 1: //Arriba
							if (fila - 1 < 0 || this.ventana.getModelo().getCasillas()[fila - 1][columna].getPersonajes()[0] != null) {
							} else {
								fila--;
								movimientos++;
							}
							break;
						case 2: //Abajo
							if (fila + 1 > 10 || this.ventana.getModelo().getCasillas()[fila + 1][columna].getPersonajes()[0] != null) {
							} else {
								fila++;
								movimientos++;
							}
							break;
						case 3: //Izquierda
							if (columna - 1 < 0 || this.ventana.getModelo().getCasillas()[fila][columna - 1].getPersonajes()[0] != null) {
							} else {
								columna--;
								movimientos++;
							}
							break;
						case 4: //Derecha
							if (columna + 1 > 10 || this.ventana.getModelo().getCasillas()[fila][columna + 1].getPersonajes()[0] != null) {
							} else {
								columna++;
								movimientos++;
							}
							break;
						}
						emergency_exit++;
					}
					movimientos = 0;
					this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[0] = enemy;
					enemigos.add(this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[0]);
					this.modelo.getCasillas()[fila][columna].setEvento(Combate.getInstance());
					fondo = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[fila][columna].getEdificio().getRuta())).getImage();
					if(this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1] != null) {
						personaje = new ImageIcon(getClass().getResource("../resources/extras/battle.png")).getImage();
					} else {
						personaje = new ImageIcon(getClass().getResource(ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[0].getRuta())).getImage();
					}
					this.ventana.getTablero()[fila][columna].setIcon(new CompoundIcon(
							new ImageIcon(fondo.getScaledInstance(60, 60, Image.SCALE_SMOOTH)),
							new ImageIcon(personaje.getScaledInstance(60, 60, Image.SCALE_SMOOTH))
							));
				}
			}
		}
	}
	
	/*
	 * Metodo que controla el movimiento del protagonista (se le llama cada vez que se pulsa una flecha de direccion)
	 * Siempre teniendo en cuenta que al protagonista le queden movimientos
	 * Este metodo mueve al jugador a la casilla correspondiente en base al boton pulsado
	 */

	private void moveHeroe(int elec) {
		if(this.movimientos > 0) {
			int fila = 0;
			int columna = 0;
			Personaje per = null;
			for (int i = 0; i < this.modelo.getCasillas().length; i++) {
				for (int j = 0; j < this.modelo.getCasillas()[i].length; j++) {
					if(this.modelo.getCasillas()[i][j].getPersonajes()[1] != null) { //Encontramos al protagonista
						//Nos guardamos sus datos actuales
						per = this.modelo.getCasillas()[i][j].getPersonajes()[1];
						fila = i;
						columna = j;
					}
				}
			}
			//Actualizamos la imgen de la casilla actual como si el ptrota ya se hubiera movido
			Image personaje;
			Image img = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[fila][columna].getEdificio().getRuta())).getImage();
			this.ventana.getTablero()[fila][columna].setIcon(new ImageIcon(img.getScaledInstance(60, 60, Image.SCALE_SMOOTH)));
			//Probablemente inecesario
			if(this.modelo.getCasillas()[fila][columna].getPersonajes()[0] != null) {
				img = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[fila][columna].getPersonajes()[0].getRuta())).getImage();
				this.ventana.getTablero()[fila][columna].setIcon(new CompoundIcon(this.ventana.getTablero()[fila][columna].getIcon(), new ImageIcon(img.getScaledInstance(60, 60, Image.SCALE_SMOOTH))));
			}
			//
			//Borramos al protagonista de la casilla actual
			this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1] = null;
			switch (elec) { //Elegimos donde moverlo en base al boton pulsado
			case 0x26: //Arriba
				if (fila - 1 < 0) {
					System.out.println("Casilla Inalcanzable");
				} else {
					fila--;
					this.movimientos--;
				}
				break;
			case 0x28: //Abajo
				if (fila + 1 > 10) {
					System.out.println("Casilla Inalcanzable");
				} else {
					fila++;
					this.movimientos--;
				}
				break;
			case 0x25: //Izquierda
				if (columna - 1 < 0) {
					System.out.println("Casilla Inalcanzable");
				} else {
					columna--;
					this.movimientos--;
				}
				break;
			case 0x27: //Derecha
				if (columna + 1 > 10) {
					System.out.println("Casilla Inalcanzable");
				} else {
					columna++;
					this.movimientos--;
				}
				break;
			}
			//Movemos al prota y cambiamos imagen
			this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1] = per;
			img = new ImageIcon(getClass().getResource(this.modelo.getCasillas()[fila][columna].getEdificio().getRuta())).getImage();
			if(this.ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[0] != null) { //En caso de que ya haya un enemigo ponemos una imagen especial
				personaje = new ImageIcon(getClass().getResource("../resources/extras/battle.png")).getImage();
			} else {
				personaje = new ImageIcon(getClass().getResource(ventana.getModelo().getCasillas()[fila][columna].getPersonajes()[1].getRuta())).getImage();
			}
			this.ventana.getTablero()[fila][columna].setIcon(new CompoundIcon(
					new ImageIcon(img.getScaledInstance(60, 60, Image.SCALE_SMOOTH)),
					new ImageIcon(personaje.getScaledInstance(60, 60, Image.SCALE_SMOOTH))
					));
		}
	}

	/*
	 * Getters y setters
	 */
	public TitleController getTitle() {
		return title;
	}

	public void setTitle(TitleController title) {
		this.title = title;
	}

	public ElecController getElec() {
		return elec;
	}

	public void setElec(ElecController elec) {
		this.elec = elec;
	}

	public TableroModel getModelo() {
		return modelo;
	}

	public void setModelo(TableroModel modelo) {
		this.modelo = modelo;
	}

	public BatoiKillerView getVentana() {
		return ventana;
	}

	public void setVentana(BatoiKillerView ventana) {
		this.ventana = ventana;
	}

}
